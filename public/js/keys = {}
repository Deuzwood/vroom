keys = {}
fariLights = false;
onkeydown = function(e){
    keys[e.key] = true; 
}
onkeyup = function(e){
    keys[e.key] = false;
}
onkeypress = function(e){
    if(e.key == "f"){
        car.frontLights.switch ? car.frontLights.switch = false : car.frontLights.switch = true;
    }
}
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
scene.background = new THREE.Color( 0x0c0c0d );

var renderer = new THREE.WebGLRenderer({});



renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
renderer.shadowMapSoft = true;

renderer.setClearColor( 0x000000, 0 );
renderer.setSize( window.innerWidth, window.innerHeight );
const canvas = renderer.domElement

document.body.appendChild( canvas );

var axesHelper = new THREE.AxesHelper( 100);
//scene.add( axesHelper );

camera.rotation.set(Math.PI/-2,Math.PI/-9,Math.PI/-2);
camera.position.set(0,10,0);

car = {
    stats:{
        acceleration: 0.003,
        resistance : 0.0015,
        enginePower : 0,
        maxEnginePower : 0.3,
        maxReverseEnginePower : 0.1,
        steerAngle:{
            current:0,
            max:20,
            change:2,
            toR : function(){
                return this.current * Math.PI/180;
            }
        }
    },
    spotInLight : {
        angle :0,
        spotLight : {},
        init : function(){
            this.spotLight  = new THREE.SpotLight(0xffd752)
            this.spotLight.position.set(0,10,0);
            this.spotLight.angle = Math.PI/8
            this.spotLight.penumbra = 0.1
            this.spotLight.decay = 2
            this.spotLight.intensity = 0.5
            this.spotLight.castShadow = true
            scene.add(this.spotLight)
            this.spotLight.target = car.model
        },
        update : function(){
            this.spotLight.position.set(car.model.position.x + Math.sin(this.angle) * 2,8,car.model.position.z+ Math.cos(this.angle)* 2)
            this.angle += 0.05
        }
    },
    parts:{},
    model:{},
    frontLights:{
        switch : true,
        meshes:[],
        spotLights:{},
        init:function(){
            object = this;
            this.meshes.forEach(function(mesh){
                object.spotLights[mesh.name + "SpotLight"] = new THREE.SpotLight(0xffd752);
                object.spotLights[mesh.name + "SpotLight"].castShadow = true
                object.spotLights[mesh.name + "SpotLight"].distance = 20
                object.spotLights[mesh.name + "SpotLight"].intensity = 5
                object.spotLights[mesh.name + "SpotLight"].power = 2
                object.spotLights[mesh.name + "SpotLight"].target = new THREE.Object3D();
                scene.add(object.spotLights[mesh.name + "SpotLight"])
                scene.add(object.spotLights[mesh.name + "SpotLight"].target)
            })
        },
        update:function(){
            object = this;
            this.meshes.forEach(function(mesh){
                temp = new THREE.Vector2(mesh.position.z,mesh.position.x);
                temp.rotateAround({x:0,y:0},car.model.rotation.y );
                object.spotLights[mesh.name + "SpotLight"].position.x = car.model.position.x + temp.y
                object.spotLights[mesh.name + "SpotLight"].position.y = car.model.position.y + mesh.position.y
                object.spotLights[mesh.name + "SpotLight"].position.z = car.model.position.z + temp.x 
                
                object.spotLights[mesh.name + "SpotLight"].target.position.x = car.model.position.x + temp.y + Math.sin(car.model.rotation.y)
                object.spotLights[mesh.name + "SpotLight"].target.position.y = car.model.position.y + mesh.position.y;
                object.spotLights[mesh.name + "SpotLight"].target.position.z = car.model.position.z + temp.x + Math.cos(car.model.rotation.y)
                
                object.switch ? mesh.material = new THREE.MeshBasicMaterial({color:0xffd752}) : mesh.material = new THREE.MeshBasicMaterial({color:0x6f6f6f});
                object.switch ? object.spotLights[mesh.name + "SpotLight"].intensity = 1 : object.spotLights[mesh.name + "SpotLight"].intensity = 0;
            })
        }
    },
    backLights :{
        meshes:[],
        spotLights:{},
        init:function(){
            object = this;
            this.meshes.forEach(function(mesh){
                object.spotLights[mesh.name + "SpotLight"] = new THREE.PointLight(0xef2d2d,1,100);
                object.spotLights[mesh.name + "SpotLight"].distance = 1 
                 scene.add(object.spotLights[mesh.name + "SpotLight"])
            })
        },
        update:function(){
            object = this;
            this.meshes.forEach(function(mesh){
                temp = new THREE.Vector2(mesh.position.z,mesh.position.x);
                temp.rotateAround({x:0,y:0},car.model.rotation.y );
                object.spotLights[mesh.name + "SpotLight"].position.x = car.model.position.x + temp.y
                object.spotLights[mesh.name + "SpotLight"].position.y = car.model.position.y + mesh.position.y
                object.spotLights[mesh.name + "SpotLight"].position.z = car.model.position.z + temp.x 
                
                
                keys["ArrowDown"] && !keys["ArrowUp"] ? mesh.material = new THREE.MeshBasicMaterial({color:0xef2d2d}) : mesh.material = new THREE.MeshBasicMaterial({color:0x6f6f6f});
                keys["ArrowDown"] && !keys["ArrowUp"] ? object.spotLights[mesh.name + "SpotLight"].intensity = 3 : object.spotLights[mesh.name + "SpotLight"].intensity = 0;
            })
        }
    },
    move : function(){
        if (keys["ArrowUp"]) {
            this.stats.enginePower = Math.min(this.stats.maxEnginePower, this.stats.enginePower + this.stats.acceleration);
        } else if (keys["ArrowDown"]) {
            this.stats.enginePower = Math.max(-this.stats.maxReverseEnginePower, this.stats.enginePower - this.stats.acceleration);
        }
        if (keys["ArrowLeft"]) {
            this.stats.steerAngle.current = Math.min(this.stats.steerAngle.max, this.stats.steerAngle.current + this.stats.steerAngle.change);
            this.parts.frontLeftWheel.rotation.y = -this.stats.steerAngle.toR()
            this.parts.frontRightWheel.rotation.y = -this.stats.steerAngle.toR()
        } else if (keys["ArrowRight"]) {
            this.stats.steerAngle.current = Math.max(-this.stats.steerAngle.max, this.stats.steerAngle.current - this.stats.steerAngle.change);
            this.parts.frontLeftWheel.rotation.y = -this.stats.steerAngle.toR()
            this.parts.frontRightWheel.rotation.y = -this.stats.steerAngle.toR()
        }
    
        this.stats.enginePower > 0 ? this.stats.enginePower = Math.max(0, this.stats.enginePower - this.stats.resistance) : this.stats.enginePower = Math.min(0, this.stats.enginePower + this.stats.resistance);
    
        this.stats.steerAngle.current = this.stats.steerAngle.current > 0 ? Math.max(0, this.stats.steerAngle.current - this.stats.steerAngle.change / 2) : Math.min(0, this.stats.steerAngle.current + this.stats.steerAngle.change / 2);
    
        this.parts.frontLeftWheel.rotation.y = this.stats.steerAngle.toR()
        this.parts.frontRightWheel.rotation.y = this.stats.steerAngle.toR()
        this.model.position.x += Math.sin(this.model.rotation.y + this.stats.steerAngle.toR()) * this.stats.enginePower;
        this.model.position.z += Math.cos(this.model.rotation.y + this.stats.steerAngle.toR()) * this.stats.enginePower;
        this.model.rotation.y = this.model.rotation.y % (2 * Math.PI) + this.stats.steerAngle.toR() * this.stats.enginePower * 0.85;
    
        //
    }
}

var loader = new THREE.GLTFLoader();
loader.load("car.gltf", function (gltf) {
    model = gltf.scene
    model.scale.set(1,1,1);
    model.position.y = 0;
    model.position.x = 0;
    model.position.z = 0;

    model.traverse((o) => {
        if (o.isMesh) {
            console.log(o.name)
            o.castShadow = true;
            o.receiveShadow = true;
            o.material = new THREE.MeshPhongMaterial({
                map: o.material.map,
            })
            if(o.name.endsWith("Light")){
                o.name.startsWith("front") ? car.frontLights.meshes.push(o) : car.backLights.meshes.push(o);
            }else{
                car.parts[o.name] = o;
            }
        }
    });
    car.frontLights.init();
    car.backLights.init();
    
    car.model = model
    scene.add(car.model);
    car.spotInLight.init()
})

var city = {
    streetLights : [],
    block:[]
}

loader.load("city.gltf",function(gltf){
    
    model = gltf.scene
    
    model.scale.set(0.03,0.03,0.03);
    
    model.traverse((o) => {
     if (o.isMesh) {

        o.castShadow = true;
        o.receiveShadow = true;
         o.material = new THREE.MeshPhongMaterial({
             map : o.material.map,
                 
         })
         
         if(o.name.includes("Light") && !o.name.includes("BULB")){
             city.streetLights.push(o)
         }
         
         
     }})
    
    
    var box = new THREE.Box3().setFromObject(model);
    console.log(box.max,box.min,box.getSize())
    for(x=-1;x<3;x++){
        for(y=-1;y<3;y++){
            console.log({x,y})
            city.block.push(model.clone())
            city.block[city.block.length-1].position.z = box.max.z + box.getSize().z * x
            city.block[city.block.length-1].position.x = box.min.x + box.getSize().x * -y
            city.block[city.block.length-1].position.y = 0
            
            scene.add(city.block[city.block.length-1])
        }
    }

    
})

lightings = {}

var light = new THREE.AmbientLight( 0x535353 ); // soft white light
scene.add( light );



window.onresize = function(){
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
}
            
function animate(){
    requestAnimationFrame(animate);
    
        car.move()
        car.frontLights.update()
        car.backLights.update()
        car.spotInLight.update()
        
        
        renderer.setPixelRatio(window.devicePixelRatio);

        camera.position.x = car.model.position.x -2;
        camera.position.z = car.model.position.z;
    
       

	renderer.render( scene, camera );
}
animate()